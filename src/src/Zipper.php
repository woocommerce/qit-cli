<?php

namespace QIT_CLI;

use QIT_CLI\Environment\Docker;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Process\Process;

class Zipper {
	/** @var OutputInterface */
	private $output;

	/** @var Docker */
	private $docker;

	public function __construct( OutputInterface $output, Docker $docker ) {
		$this->output = $output;
		$this->docker = $docker;
	}

	public function extract_zip( string $zip_file, string $extract_to ): void {
		if ( ! file_exists( $zip_file ) ) {
			throw new \InvalidArgumentException( 'Zip file does not exist.' );
		}

		if ( ! file_exists( $extract_to ) ) {
			if ( ! mkdir( $extract_to, 0755, true ) ) {
				throw new \RuntimeException( 'Could not create directory.' );
			}
		}

		// Make sure $extract_to is within Config Dir or sys_get_temp_dir.
		if ( strpos( normalize_path( $extract_to ), Config::get_qit_dir() ) !== 0 && strpos( normalize_path( $extract_to ), normalize_path( sys_get_temp_dir() ) ) !== 0 ) {
			throw new \RuntimeException( 'Invalid directory.' );
		}

		$this->validate_zip( $zip_file );

		$start = microtime( true );

		if ( class_exists( 'ZipArchive' ) ) {
			// Use zip from host PHP if available, as it's faster on Macs.
			$zip = new \ZipArchive();
			if ( $zip->open( $zip_file ) === true ) {
				$zip->extractTo( $extract_to );
				$zip->close();

				if ( $this->output->isVeryVerbose() ) {
					$this->output->writeln( sprintf( 'ZipArchive extraction of %s successful (%f seconds).', basename( $zip_file ), microtime( true ) - $start ) );
				}

				return;
			} else {
				if ( $this->output->isVeryVerbose() ) {
					$this->output->writeln( sprintf( 'ZipArchive extraction of %s failed, falling back to Docker (%f seconds).', basename( $zip_file ), microtime( true ) - $start ) );
				}
			}
		}

		$zip_process = new Process( [
			$this->docker->find_docker(),
			'run',
			'--rm',
			'--user',
			implode( ':', Docker::get_user_and_group() ),
			'-v',
			"$zip_file:/app/file.zip",
			'-v',
			normalize_path( $extract_to ) . ':/app/extracted',
			'joshkeegan/zip:latest',
			'sh',
			'-c',
			'unzip /app/file.zip -d /app/extracted',
		] );

		$start = microtime( true );
		$zip_process->mustRun( function ( $type, $out ) {
			if ( $this->output->isVeryVerbose() ) {
				'Docker ZIP Extraction: ' . $this->output->writeln( $out );
			}
		} );
		if ( $this->output->isVeryVerbose() ) {
			$this->output->writeln( sprintf( 'Docker ZIP extraction of %s successful (%f seconds).', basename( $zip_file ), microtime( true ) - $start ) );
		}
	}

	public function validate_zip( string $zip_file ): void {
		$start = microtime( true );

		if ( class_exists( 'ZipArchive' ) ) {
			// Use zip from host PHP if available, as it's faster on Macs.
			$zip = new \ZipArchive();
			if ( $zip->open( $zip_file, \ZipArchive::CHECKCONS ) === true ) {
				$zip->close();

				if ( $this->output->isVeryVerbose() ) {
					$this->output->writeln( sprintf( 'ZipArchive validation of %s successful (%f seconds).', basename( $zip_file ), microtime( true ) - $start ) );
				}

				return;
			} else {
				if ( $this->output->isVeryVerbose() ) {
					$this->output->writeln( sprintf( 'ZipArchive validation of %s failed, falling back to Docker (%f seconds).', basename( $zip_file ), microtime( true ) - $start ) );
				}
			}
		}

		$start = microtime( true );

		// Using Docker as a fallback if ZipArchive does not exist or fails.
		// Zips generated by MacOS Archive Utility can fail the consistency check but still be valid.
		$zip_process = new Process( [
			$this->docker->find_docker(),
			'run',
			'--rm',
			'--user',
			implode( ':', Docker::get_user_and_group() ),
			'-v',
			"$zip_file:/app/file.zip",
			'joshkeegan/zip:latest',
			'sh',
			'-c',
			'zip -T /app/file.zip',
		] );

		$zip_process->mustRun( function ( $type, $out ) {
			if ( $this->output->isVeryVerbose() ) {
				$this->output->write( 'Docker ZIP Validation: ' . $out );
			}
		} );

		if ( $this->output->isVeryVerbose() ) {
			$this->output->writeln( sprintf( 'Docker ZIP validation of %s successful (%f seconds).', basename( $zip_file ), microtime( true ) - $start ) );
		}
	}

	public function zip_directory( string $source_dir, string $output_zip_file, array $exclude = [] ): void {
		if ( ! is_dir( $source_dir ) ) {
			throw new \InvalidArgumentException( 'Source directory does not exist.' );
		}

		$source_dir = rtrim( $source_dir, DIRECTORY_SEPARATOR );

		// Creating a temporary directory to store the zipped file
		$temp_dir = sys_get_temp_dir() . '/' . uniqid( 'zip_', true );
		if ( ! mkdir( $temp_dir, 0755, true ) ) {
			throw new \RuntimeException( 'Could not create temporary directory.' );
		}

		// Building the exclusion string for the Docker command
		$exclude_string = '';
		foreach ( $exclude as $item ) {
			$exclude_string .= " '$item' ";
		}

		$docker_command = [
			$this->docker->find_docker(),
			'run',
			'--rm',
			'--user',
			implode( ':', Docker::get_user_and_group() ),
			'-v',
			"$source_dir:/app/source",
			'-v',
			"$temp_dir:/app/dest",
			'joshkeegan/zip:latest',
			'sh',
			'-c',
			"cd /app/source && zip -r /app/dest/output.zip . -x $exclude_string",
		];

		$zip_process = new Process( $docker_command );
		$zip_process->mustRun();

		// Move the zipped file from the temp directory to the desired output location
		rename( "$temp_dir/output.zip", $output_zip_file );

		// Clean up the temporary directory
		rmdir( $temp_dir );
	}
}
