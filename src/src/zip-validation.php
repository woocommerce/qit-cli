<?php
/**
 * QIT Zip Validation.
 *
 * Requires PHP version 7.2 or later.
 * Tests for this file are present in the QIT CLI UploadTest.php file.
 *
 * This PHP file does not require WordPress, and provides functionality for validating zip files.
 * It is designed to verify the integrity and structure of zip files according to specific criteria.
 * These criteria include checks for a consistent zip structure, the presence of a
 * specific directory within the zip, and the location of a plugin entrypoint.
 *
 * It utilizes a generator for efficient scanning and real-time feedback. As it scans the zip file,
 * it yields progress updates with information about the total files, number of scanned files,
 * and the percentage of files scanned so far.
 *
 * Both the CLI and the Manager should use this same file.
 */

namespace QIT_ZIP_Validation;

use Exception;
use ZipArchive;

class InvalidZipException extends Exception {
	public static function not_a_zip(): self {
		return new self( 'The file you uploaded is not a zip file.', 400 );
	}

	public static function plugin_entrypoint_not_found(): self {
		return new self( 'We could not find a valid plugin inside this zip.', 400 );
	}

	public static function cannot_read_zip_index(): self {
		return new self( 'Cannot read zip index.', 400 );
	}

	public static function invalid_plugin_zip( string $zip_file, string $plugin_slug ): self {
		return new self( "Zip validation failed. We expected to find a parent directory named '$plugin_slug' in the root of the zip, if the parent directory can't be found, the zip name should be '$plugin_slug.zip'. It was '$zip_file'. Please check https://woocommerce.github.io/qit-documentation/#/zip for more information.", 400 );
	}
}

// phpcs:ignore Generic.Files.OneObjectStructurePerFile.MultipleFound
class InconsistentZipException extends Exception {
	/**
	 * Error 21 is for inconsistent Zip Archive.
	 *
	 * This happens when the file is a zip file, but contains inconsistent metadata about the zip contents.
	 * This can happen on zip files generated by the macOS Archive Utility.
	 *
	 * @link https://github.com/nih-at/libzip/issues/341
	 */
	public static function inconsistent_zip(): self {
		return new self( 'The zip file failed a consistency check.', 400 );
	}
}

/**
 * Checks if the given zip file passes a zip consistency check.
 *
 * @param string $filepath The zip file path.
 *
 * @return void
 * @throws InvalidZipException If the file is not a zip file.
 *
 * @throws InconsistentZipException If the zip file is valid, but not compliant with ZIP especification
 *                                  such as the ones generated by MacOS Archiver.
 */
function check_zip_consistency( string $filepath ) {
	$zip = new ZipArchive();

	$opened = $zip->open( $filepath, ZipArchive::CHECKCONS );

	if ( $opened === 21 ) {
		throw InconsistentZipException::inconsistent_zip();
	}

	if ( $opened !== true ) {
		throw InvalidZipException::not_a_zip();
	}
}

/**
 * Checks if the given zip file contains a directory with the same name as the plugin slug,
 * or that the zip name matches the plugin slug as a fallback.
 *
 * This function is a generator and will yield progress updates as it scans the zip file.
 * The yielded updates are associative arrays with the following keys:
 * - 'total_files': The total number of files in the zip.
 * - 'scanned_files': The number of files scanned so far.
 * - 'scanned_percentage': The percentage of the total files that have been scanned so far.
 *
 * Once all files have been scanned or the necessary information has been found, the function will
 * return an associative array with the same keys as the yielded updates.
 *
 * @param string $zip_file The zip file path.
 * @param string $plugin_slug The plugin slug.
 *
 * @return \Generator|array<string,mixed> A generator that yields progress updates as scanning
 *                                        progresses and ultimately returns the final counts.
 * @throws InvalidZipException If the zip file is invalid.
 */
function validate_zip_plugin( string $zip_file, string $plugin_slug ) {
	$zip = new ZipArchive();

	$zip_filename = basename( $zip_file );

	// Do not check for consistency when opening, so that it opens macOS Archive Utility zips.
	$opened = $zip->open( $zip_file );

	if ( $opened !== true ) {
		throw InvalidZipException::not_a_zip();
	}

	// Example (foo => foo/).
	$parent_dir = strtolower( trim( trim( $plugin_slug ), '/' ) . '/' );

	$found_parent_directory  = false;
	$found_plugin_entrypoint = false;

	/*
	 * This function iterates over the contents of a zip file to validate that it contains
	 * both the parent directory and the plugin entrypoint. A valid zip file in this context is one
	 * that has a directory structure matching the parent directory, and contains a PHP file at root or one
	 * level deep that is identified as the plugin entrypoint.
	 *
	 * We use the zip index, which lists all files in the zip, for our search. We iterate over
	 * this index and check each file against our validation criteria.
	 *
	 * It's common for zip files to have directories listed first, so a linear search from top
	 * to bottom can be inefficient for finding the plugin entrypoint, which often lives in the root directory.
	 *
	 * To improve efficiency, we use a two-pointer or bidirectional approach. This means we iterate the zip index from both
	 * ends - we search one item from the beginning, then one item from the end, alternating until
	 * we meet in the middle. This approach can be more efficient when the required files are likely
	 * to be near the start or end of the index.
	 */
	$left          = 0;
	$right         = $zip->numFiles - 1; // phpcs:ignore WordPress.NamingConventions.ValidVariableName.UsedPropertyNotSnakeCase
	$scanned_files = 0;

	while ( $left <= $right ) {
		foreach ( [ $left, $right ] as $i ) {
			/*
			 * We use a generator here to give the caller of this function insight
			 * on what is happening in this function.
			 *
			 * Think of it as a lightweight alternative to do_action:
			 * The caller can read the following variables, but cannot change them.
			 *
			 * This is used in the CLI to show a progress bar.
			 */
			yield [
				'total_files'        => $zip->numFiles, // phpcs:ignore WordPress.NamingConventions.ValidVariableName.UsedPropertyNotSnakeCase
				'scanned_files'      => $scanned_files,
				'scanned_percentage' => (float) number_format( ( $scanned_files / $zip->numFiles ) * 100, 2 ), // phpcs:ignore WordPress.NamingConventions.ValidVariableName.UsedPropertyNotSnakeCase
			];

			$info = $zip->statIndex( $i );
			$scanned_files ++;

			if ( ! $info ) {
				throw InvalidZipException::cannot_read_zip_index();
			}

			if ( ! $found_parent_directory && str_starts_with( strtolower( $info['name'] ), $parent_dir ) ) {
				$found_parent_directory = true;
			}

			$dir_depth = substr_count( trim( $info['name'], '/' ), '/' );

			if ( $dir_depth <= 1 && str_ends_with( strtolower( $info['name'] ), '.php' ) ) {
				/**
				 * Read the contents directly inside the zip, without extracting.
				 * Search for the plugin header in the first 8KB of the file, mimicking WordPress Core.
				 *
				 * @see get_plugin_data()
				 * @see get_file_data()
				 */
				if ( stripos( file_get_contents( "zip://$zip_file#{$info['name']}", false, null, 0, 8 * 1024 ), 'Plugin Name' ) !== false ) { // phpcs:ignore WordPress.WP.AlternativeFunctions.file_get_contents_file_get_contents
					$found_plugin_entrypoint = true;

					/*
					 * When we find the plugin entrypoint, we can stop searching through the zip.
					 *
					 * By the time we find the plugin entrypoint, the parent directory would have been found already
					 * if it exists, because a valid parent directory must contain the plugin entrypoint.
					 *
					 * So if we found the plugin entrypoint without finding the parent directory, it means that this
					 * zip does not contain a valid parent directory. Thus, we can safely break out of both loops at
					 * this point, as we have gathered all the required information.
					 */
					break 2;
				}
			}
		}

		$left ++;
		$right --;
	}

	if ( ! $found_plugin_entrypoint ) {
		throw InvalidZipException::plugin_entrypoint_not_found();
	}

	// We didn't find a parent directory.
	if ( ! $found_parent_directory ) {
		// If the zip does not have a parent directory matching the plugin slug, the zip file should match the plugin slug.
		if ( $zip_filename !== $plugin_slug . '.zip' ) {
			// If both conditions fails, then the zip file is invalid.
			throw InvalidZipException::invalid_plugin_zip( $zip_filename, $plugin_slug );
		}
	}

	return [
		'total_files'        => $zip->numFiles, // phpcs:ignore WordPress.NamingConventions.ValidVariableName.UsedPropertyNotSnakeCase
		'scanned_files'      => $scanned_files,
		'scanned_percentage' => (float) number_format( ( $scanned_files / $zip->numFiles ) * 100, 2 ), // phpcs:ignore WordPress.NamingConventions.ValidVariableName.UsedPropertyNotSnakeCase
	];
}
